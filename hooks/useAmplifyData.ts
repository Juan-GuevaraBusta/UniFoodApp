// hooks/useAmplifyData.ts - Versi√≥n corregida para Gen 2 - COMPLETA
import type { Schema } from '@/amplify/data/resource';
import { getRestaurantInfoByEmail } from '@/constants/userRoles';
import { fetchAuthSession, getCurrentUser } from 'aws-amplify/auth';
import { generateClient } from 'aws-amplify/data';
import { useAuth } from './useAuth';

// ‚úÖ Cliente tipado de Gen 2 - usa el schema definido
const client = generateClient<Schema>({
    authMode: 'userPool', // Especificar modo de auth expl√≠citamente
});

// ‚úÖ Tipos para los resultados
interface PedidoResult {
    success: boolean;
    error?: string;
    numeroOrden?: string;
    pedidoId?: string;
    message?: string;
    pedido?: any;
    needsReauth?: boolean;
}

interface PedidosResult {
    success: boolean;
    error?: string;
    pedidos?: any[];
    restaurantInfo?: any;
    needsReauth?: boolean;
}

interface UpdateResult {
    success: boolean;
    error?: string;
    pedido?: any;
    needsReauth?: boolean;
}

export const useAmplifyData = () => {
    const { user, isAuthenticated, verificarSesion } = useAuth();

    const verificarAutenticacion = async () => {
        try {
            // ‚úÖ Verificar sesi√≥n directamente con AWS Amplify
            const session = await fetchAuthSession();
            if (!session.tokens?.accessToken) {
                throw new Error('No hay tokens de acceso v√°lidos');
            }

            // ‚úÖ Verificar usuario actual
            const currentUser = await getCurrentUser();
            if (!currentUser) {
                throw new Error('No hay usuario actual');
            }

            const email = currentUser.signInDetails?.loginId || '';
            if (!email) {
                throw new Error('No se pudo obtener el email del usuario');
            }

            console.log('‚úÖ Usuario autenticado verificado:', {
                email: email,
                hasAccessToken: !!session.tokens?.accessToken,
                hasIdToken: !!session.tokens?.idToken
            });

            return true;

        } catch (error) {
            console.error('‚ùå Error de autenticaci√≥n:', error);
            throw new Error('Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.');
        }
    };

    // ‚úÖ CREAR PEDIDO usando Gen 2 client - CORREGIDO
    const crearPedido = async (carritoItems: any[], total: number): Promise<PedidoResult> => {
        try {
            console.log('üìù Creando pedido con Gen 2 client...');

            if (!carritoItems || carritoItems.length === 0) {
                return {
                    success: false,
                    error: 'El carrito est√° vac√≠o'
                };
            }

            // ‚úÖ Verificar autenticaci√≥n ANTES de hacer la llamada
            await verificarAutenticacion();

            // ‚úÖ Obtener email del usuario autenticado
            const currentUser = await getCurrentUser();
            const userEmail = currentUser.signInDetails?.loginId || '';

            if (!userEmail) {
                return {
                    success: false,
                    error: 'No se pudo obtener el email del usuario'
                };
            }

            const primerItem = carritoItems[0];
            const restauranteId = primerItem.idRestaurante.toString();
            const universidadId = primerItem.universidadId;
            const subtotal = total - Math.round(total * 0.05);
            const tarifaServicio = Math.round(total * 0.05);
            const numeroOrden = generateShortOrderNumber();

            // ‚úÖ CR√çTICO: Preparar itemsPedido como JSON string
            const itemsPedidoArray = carritoItems.map(item => ({
                platoId: item.plato.idPlato,
                platoNombre: item.plato.nombre,
                platoDescripcion: item.plato.descripcion,
                precioUnitario: item.plato.precio,
                cantidad: item.cantidad,
                comentarios: item.comentarios || undefined,
                toppingsSeleccionados: item.toppingsSeleccionados || [],
                toppingsBaseRemocionados: item.toppingsBaseRemocionados || [],
                precioTotal: item.precioTotal,
                totalItem: item.precioTotal * item.cantidad,
                idUnico: item.idUnico,
                restauranteNombre: item.nombreRestaurante,
                universidadNombre: item.nombreUniversidad
            }));

            const pedidoData = {
                numeroOrden,
                usuarioEmail: userEmail,
                restauranteId,
                subtotal,
                tarifaServicio,
                total,
                estado: 'pendiente' as const,
                fechaPedido: new Date().toISOString(),
                comentariosCliente: carritoItems
                    .filter(item => item.comentarios?.trim())
                    .map(item => `${item.plato.nombre}: ${item.comentarios}`)
                    .join('; ') || undefined,
                universidadId,
                restauranteEstado: `${restauranteId}#pendiente`,
                // ‚úÖ CORREGIDO: Serializar itemsPedido como JSON string
                itemsPedido: JSON.stringify(itemsPedidoArray)
            };

            console.log('üìã Creando pedido con Gen 2:', {
                numeroOrden,
                restauranteId,
                universidadId,
                total,
                userEmail: userEmail,
                itemsCount: itemsPedidoArray.length,
                itemsPedidoType: typeof pedidoData.itemsPedido
            });

            // ‚úÖ Usar client.models.Pedido.create en lugar de GraphQL manual
            const { data: pedido, errors } = await client.models.Pedido.create(pedidoData);

            if (errors && errors.length > 0) {
                console.error('‚ùå Errores en creaci√≥n:', errors);

                // ‚úÖ Detectar errores de autenticaci√≥n espec√≠ficos
                const authError = errors.find(err =>
                    err.message?.includes('Unauthorized') ||
                    err.message?.includes('Not Authorized') ||
                    err.message?.includes('authentication')
                );

                if (authError) {
                    return {
                        success: false,
                        error: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
                        needsReauth: true
                    };
                }

                return {
                    success: false,
                    error: errors[0].message || 'Error creando pedido'
                };
            }

            if (!pedido) {
                return {
                    success: false,
                    error: 'No se pudo crear el pedido'
                };
            }

            console.log('‚úÖ Pedido creado exitosamente con Gen 2:', pedido);

            return {
                success: true,
                numeroOrden: pedido.numeroOrden,
                pedidoId: pedido.id,
                message: 'Pedido enviado al restaurante',
                pedido
            };

        } catch (error: any) {
            console.error('‚ùå Error creando pedido:', error);

            // ‚úÖ Manejo mejorado de errores de autenticaci√≥n
            if (error.message?.includes('autenticaci√≥n') ||
                error.message?.includes('authentication') ||
                error.message?.includes('Unauthorized') ||
                error.message?.includes('Not Authorized') ||
                error.name?.includes('NotAuthorizedException') ||
                error.name?.includes('UnauthorizedException')) {
                return {
                    success: false,
                    error: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
                    needsReauth: true
                };
            }

            return {
                success: false,
                error: error.message || 'Error interno al procesar el pedido'
            };
        }
    };

    // ‚úÖ OBTENER PEDIDOS - Adaptado para Gen 2 con parsing JSON
    const obtenerPedidosRestaurante = async (restauranteId: number, estado?: string): Promise<PedidosResult> => {
        try {
            // ‚úÖ Verificar autenticaci√≥n primero
            await verificarAutenticacion();

            // ‚úÖ Obtener informaci√≥n del restaurante del usuario autenticado
            const currentUser = await getCurrentUser();
            const userEmail = currentUser.signInDetails?.loginId || '';
            const restaurantInfo = getRestaurantInfoByEmail(userEmail);

            if (!restaurantInfo) {
                return {
                    success: false,
                    error: 'No eres due√±o de un restaurante'
                };
            }

            console.log('üìã Obteniendo pedidos con Gen 2:', {
                restauranteId,
                estado: estado || 'todos'
            });

            let result;

            if (estado) {
                // ‚úÖ Filtrar por restauranteEstado usando Gen 2
                const { data: pedidos, errors } = await client.models.Pedido.list({
                    filter: {
                        restauranteEstado: {
                            eq: `${restauranteId}#${estado}`
                        }
                    }
                });

                result = { data: pedidos, errors };
            } else {
                // ‚úÖ Filtrar solo por restauranteId usando Gen 2
                const { data: pedidos, errors } = await client.models.Pedido.list({
                    filter: {
                        restauranteId: {
                            eq: restauranteId.toString()
                        }
                    }
                });

                result = { data: pedidos, errors };
            }

            if (result.errors && result.errors.length > 0) {
                console.error('‚ùå Errores obteniendo pedidos:', result.errors);

                // ‚úÖ Detectar errores de autenticaci√≥n
                const authError = result.errors.find((err: any) =>
                    err.message?.includes('Unauthorized') ||
                    err.message?.includes('Not Authorized')
                );

                if (authError) {
                    return {
                        success: false,
                        error: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
                        needsReauth: true
                    };
                }

                return {
                    success: false,
                    error: result.errors[0].message || 'Error obteniendo pedidos'
                };
            }

            const pedidos = result.data || [];

            // ‚úÖ CR√çTICO: Procesar itemsPedido (viene como string JSON)
            const pedidosProcesados = pedidos.map((pedido: any) => ({
                ...pedido,
                itemsPedido: typeof pedido.itemsPedido === 'string'
                    ? JSON.parse(pedido.itemsPedido)
                    : pedido.itemsPedido || []
            }));

            // ‚úÖ Ordenar por fecha m√°s reciente
            const pedidosOrdenados = pedidosProcesados.sort((a: any, b: any) =>
                new Date(b.fechaPedido).getTime() - new Date(a.fechaPedido).getTime()
            );

            console.log('‚úÖ Pedidos obtenidos con Gen 2:', {
                total: pedidosOrdenados.length,
                estados: pedidosOrdenados.reduce((acc: any, p: any) => {
                    acc[p.estado] = (acc[p.estado] || 0) + 1;
                    return acc;
                }, {})
            });

            return {
                success: true,
                pedidos: pedidosOrdenados,
                restaurantInfo: restaurantInfo
            };

        } catch (error: any) {
            console.error('‚ùå Error obteniendo pedidos:', error);

            if (error.message?.includes('autenticaci√≥n') ||
                error.name?.includes('NotAuthorizedException')) {
                return {
                    success: false,
                    error: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
                    needsReauth: true
                };
            }

            return {
                success: false,
                error: error.message || 'Error obteniendo pedidos del restaurante'
            };
        }
    };

    // ‚úÖ ACTUALIZAR ESTADO - Adaptado para Gen 2
    const actualizarEstadoPedido = async (pedidoId: string, nuevoEstado: string, comentarios?: string): Promise<UpdateResult> => {
        try {
            // ‚úÖ Verificar autenticaci√≥n primero
            await verificarAutenticacion();

            // ‚úÖ Obtener informaci√≥n del restaurante del usuario autenticado
            const currentUser = await getCurrentUser();
            const userEmail = currentUser.signInDetails?.loginId || '';
            const restaurantInfo = getRestaurantInfoByEmail(userEmail);

            if (!restaurantInfo) {
                return {
                    success: false,
                    error: 'No autorizado'
                };
            }

            console.log('üîÑ Actualizando pedido con Gen 2:', { pedidoId, nuevoEstado });

            // ‚úÖ Primero obtener el pedido actual usando Gen 2
            const { data: pedidoActual, errors: getErrors } = await client.models.Pedido.get({
                id: pedidoId
            });

            if (getErrors && getErrors.length > 0) {
                console.error('‚ùå Errores obteniendo pedido:', getErrors);
                return {
                    success: false,
                    error: getErrors[0].message || 'Error obteniendo pedido actual'
                };
            }

            if (!pedidoActual) {
                return {
                    success: false,
                    error: 'Pedido no encontrado'
                };
            }

            // ‚úÖ Preparar datos de actualizaci√≥n
            const updateData: any = {
                id: pedidoId,
                estado: nuevoEstado,
                restauranteEstado: `${pedidoActual.restauranteId}#${nuevoEstado}`,
            };

            const now = new Date().toISOString();
            switch (nuevoEstado) {
                case 'aceptado':
                    updateData.fechaAceptado = now;
                    updateData.tiempoEstimado = 20;
                    break;
                case 'listo':
                    updateData.fechaListo = now;
                    break;
                case 'entregado':
                    updateData.fechaEntregado = now;
                    break;
            }

            if (comentarios) {
                updateData.comentariosRestaurante = comentarios;
            }

            // ‚úÖ Actualizar usando Gen 2
            const { data: pedidoActualizado, errors: updateErrors } = await client.models.Pedido.update(updateData);

            if (updateErrors && updateErrors.length > 0) {
                console.error('‚ùå Errores actualizando pedido:', updateErrors);
                return {
                    success: false,
                    error: updateErrors[0].message || 'Error actualizando pedido'
                };
            }

            if (pedidoActualizado) {
                console.log('‚úÖ Pedido actualizado con Gen 2:', pedidoActualizado);

                return {
                    success: true,
                    pedido: pedidoActualizado
                };
            } else {
                return {
                    success: false,
                    error: 'Error: No se pudo actualizar el pedido'
                };
            }

        } catch (error: any) {
            console.error('‚ùå Error actualizando estado:', error);

            if (error.message?.includes('autenticaci√≥n') ||
                error.name?.includes('NotAuthorizedException')) {
                return {
                    success: false,
                    error: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
                    needsReauth: true
                };
            }

            return {
                success: false,
                error: error.message || 'Error actualizando el pedido'
            };
        }
    };

    // ‚úÖ OBTENER MIS PEDIDOS - Adaptado para Gen 2 con parsing JSON
    const obtenerMisPedidos = async (): Promise<PedidosResult> => {
        try {
            // ‚úÖ Verificar autenticaci√≥n primero
            await verificarAutenticacion();

            // ‚úÖ Obtener email del usuario autenticado
            const currentUser = await getCurrentUser();
            const userEmail = currentUser.signInDetails?.loginId || '';

            if (!userEmail) {
                return {
                    success: false,
                    error: 'No se pudo obtener el email del usuario'
                };
            }

            // ‚úÖ Obtener pedidos del usuario usando Gen 2
            const { data: pedidos, errors } = await client.models.Pedido.list({
                filter: {
                    usuarioEmail: {
                        eq: userEmail
                    }
                }
            });

            if (errors && errors.length > 0) {
                console.error('‚ùå Errores obteniendo mis pedidos:', errors);
                return {
                    success: false,
                    error: errors[0].message || 'Error obteniendo mis pedidos'
                };
            }

            if (!pedidos) {
                return {
                    success: false,
                    error: 'No se pudieron obtener los pedidos'
                };
            }

            // ‚úÖ CR√çTICO: Procesar itemsPedido (viene como string JSON)
            const pedidosProcesados = pedidos.map((pedido: any) => ({
                ...pedido,
                itemsPedido: typeof pedido.itemsPedido === 'string'
                    ? JSON.parse(pedido.itemsPedido)
                    : pedido.itemsPedido || []
            }));

            // ‚úÖ Ordenar por fecha m√°s reciente
            const pedidosOrdenados = pedidosProcesados.sort((a: any, b: any) =>
                new Date(b.fechaPedido).getTime() - new Date(a.fechaPedido).getTime()
            );

            return {
                success: true,
                pedidos: pedidosOrdenados
            };

        } catch (error: any) {
            console.error('‚ùå Error obteniendo mis pedidos:', error);

            if (error.name?.includes('NotAuthorizedException')) {
                return {
                    success: false,
                    error: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
                    needsReauth: true
                };
            }

            return {
                success: false,
                error: error.message || 'Error obteniendo pedidos'
            };
        }
    };

    // ‚úÖ ACTUALIZAR DISPONIBILIDAD PLATO - Usando el mismo patr√≥n que pedidos
    const actualizarDisponibilidadPlato = async (
        platoId: string,
        restauranteId: string,
        disponible: boolean,
        comentario?: string
    ): Promise<{ success: boolean; error?: string; needsReauth?: boolean }> => {
        try {
            console.log(`üîÑ Actualizando disponibilidad - Plato: ${platoId}, Restaurante: ${restauranteId}, Disponible: ${disponible}`);

            // ‚úÖ Verificar autenticaci√≥n
            await verificarAutenticacion();

            // ‚úÖ Verificar que el usuario es due√±o del restaurante
            const currentUser = await getCurrentUser();
            const userEmail = currentUser.signInDetails?.loginId || '';
            const restaurantInfo = getRestaurantInfoByEmail(userEmail);

            if (!restaurantInfo || restaurantInfo.restauranteId.toString() !== restauranteId) {
                return {
                    success: false,
                    error: 'No tienes permisos para actualizar este restaurante'
                };
            }

            // ‚úÖ Buscar disponibilidad existente
            const { data: disponibilidadExistente, errors: errorsList } = await client.models.DisponibilidadPlato.list({
                filter: {
                    restaurantePlato: { eq: `${restauranteId}#${platoId}` }
                }
            });

            if (errorsList && errorsList.length > 0) {
                console.error('‚ùå Error buscando disponibilidad existente:', errorsList);
                return {
                    success: false,
                    error: errorsList[0].message || 'Error buscando disponibilidad existente'
                };
            }

            const disponibilidadData = {
                platoId,
                restauranteId,
                disponible,
                comentario: comentario || undefined,
                fechaActualizacion: new Date().toISOString(),
                restaurantePlato: `${restauranteId}#${platoId}`
            };

            let result;

            if (disponibilidadExistente && disponibilidadExistente.length > 0) {
                // ‚úÖ Actualizar registro existente
                const { data, errors } = await client.models.DisponibilidadPlato.update({
                    id: disponibilidadExistente[0].id,
                    ...disponibilidadData
                });

                if (errors && errors.length > 0) {
                    console.error('‚ùå Error actualizando disponibilidad:', errors);
                    return {
                        success: false,
                        error: errors[0].message || 'Error actualizando disponibilidad'
                    };
                }

                result = { data, errors };
            } else {
                // ‚úÖ Crear nuevo registro
                const { data, errors } = await client.models.DisponibilidadPlato.create(disponibilidadData);

                if (errors && errors.length > 0) {
                    console.error('‚ùå Error creando disponibilidad:', errors);
                    return {
                        success: false,
                        error: errors[0].message || 'Error creando disponibilidad'
                    };
                }

                result = { data, errors };
            }

            if (result.data) {
                console.log('‚úÖ Disponibilidad actualizada exitosamente:', result.data);
                return {
                    success: true
                };
            }

            return {
                success: false,
                error: 'No se pudo actualizar la disponibilidad'
            };

        } catch (error: any) {
            console.error('‚ùå Error actualizando disponibilidad:', error);

            if (error.message?.includes('autenticaci√≥n') ||
                error.message?.includes('authentication') ||
                error.message?.includes('Unauthorized') ||
                error.message?.includes('Not Authorized') ||
                error.name?.includes('NotAuthorizedException')) {
                return {
                    success: false,
                    error: 'Sesi√≥n expirada. Por favor inicia sesi√≥n nuevamente.',
                    needsReauth: true
                };
            }

            return {
                success: false,
                error: error.message || 'Error actualizando disponibilidad'
            };
        }
    };

    // ‚úÖ OBTENER DISPONIBILIDAD RESTAURANTE - Usando el mismo patr√≥n que pedidos
    const obtenerDisponibilidadRestaurante = async (
        restauranteId: string
    ): Promise<{ success: boolean; error?: string; disponibilidad?: { [platoId: string]: boolean }; needsReauth?: boolean }> => {
        try {
            console.log(`üîÑ Obteniendo disponibilidad para restaurante ${restauranteId}...`);

            // ‚úÖ Obtener desde backend
            const { data: disponibilidadPlatos, errors } = await client.models.DisponibilidadPlato.list({
                filter: {
                    restauranteId: { eq: restauranteId }
                }
            });

            if (errors && errors.length > 0) {
                console.error('‚ùå Error obteniendo disponibilidad:', errors);
                return {
                    success: false,
                    error: errors[0].message || 'Error obteniendo disponibilidad'
                };
            }

            // ‚úÖ Procesar datos
            const disponibilidad: { [platoId: string]: boolean } = {};
            if (disponibilidadPlatos) {
                disponibilidadPlatos.forEach((item: any) => {
                    disponibilidad[item.platoId] = item.disponible;
                });
            }

            console.log(`‚úÖ Disponibilidad obtenida para restaurante ${restauranteId}:`, disponibilidad);

            return {
                success: true,
                disponibilidad
            };

        } catch (error: any) {
            console.error('‚ùå Error obteniendo disponibilidad:', error);
            return {
                success: false,
                error: error.message || 'Error obteniendo disponibilidad'
            };
        }
    };

    return {
        crearPedido,
        obtenerPedidosRestaurante,
        actualizarEstadoPedido,
        obtenerMisPedidos,
        verificarAutenticacion,
        user,

        // ‚úÖ NUEVAS: Funciones de disponibilidad
        actualizarDisponibilidadPlato,
        obtenerDisponibilidadRestaurante,
    };
};

// ‚úÖ Funci√≥n para generar n√∫mero de orden corto - sin cambios
function generateShortOrderNumber(): string {
    const timestamp = Date.now();
    const shortTimestamp = timestamp % 1000000;
    const random = Math.floor(Math.random() * 1000);

    const timestampHex = shortTimestamp.toString(16).toUpperCase().padStart(5, '0');
    const randomHex = random.toString(16).toUpperCase().padStart(3, '0');

    const part1 = timestampHex.substring(0, 3);
    const part2 = timestampHex.substring(3, 5);
    const part3 = randomHex;

    return `#${part1}${part2}-${part3}`;
}